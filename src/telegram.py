# -*- coding: utf-8 -*-
"""
Telegram –±–æ—Ç –¥–ª—è —Å–ø–æ–≤—ñ—â–µ–Ω—å —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from telegram import Bot
from telegram.error import TelegramError
from config.settings import TELEGRAM_CONFIG, API_CONFIG

logger = logging.getLogger(__name__)

class TelegramNotifier:
    """–ö–ª–∞—Å –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Å–ø–æ–≤—ñ—â–µ–Ω—å —á–µ—Ä–µ–∑ Telegram"""
    
    def __init__(self):
        self.config = TELEGRAM_CONFIG
        self.bot = None
        self.chat_id = self.config.get('chat_id')
        
        if self.config.get('bot_token') and self.config.get('enable_notifications', True):
            try:
                self.bot = Bot(token=self.config['bot_token'])
                logger.info("Telegram –±–æ—Ç —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ")
            except Exception as e:
                logger.error(f"–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó Telegram –±–æ—Ç–∞: {e}")
                self.bot = None
        else:
            logger.warning("Telegram —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–∏–º–∫–Ω–µ–Ω–æ")
    
    def get_detailed_action_info(self, action: str, reason: str = "", side: str = "") -> Tuple[str, str]:
        """–í–∏–∑–Ω–∞—á–∞—î –¥–µ—Ç–∞–ª—å–Ω–∏–π —Ç–∏–ø –¥—ñ—ó —Ç–∞ –µ–º–æ–¥–∑—ñ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π"""

        action_lower = action.lower()
        reason_lower = reason.lower() if reason else ""
        side_upper = side.upper() if side else "UNKNOWN_SIDE"

        position_suffix = ""
        if side_upper == 'BUY':
            position_suffix = " (LONG)"
        elif side_upper == 'SELL':
            position_suffix = " (SHORT)"

        # –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–Ω–∏–π –∞–Ω–∞–ª—ñ–∑ –∑–∞ reason (–±—ñ–ª—å—à —Ç–æ—á–Ω–∏–π, —è–∫—â–æ –≤—ñ–Ω –¥–µ—Ç–∞–ª—å–Ω–∏–π)
        if 'stop loss hit' in reason_lower or 'sl_hit' in action_lower: # –î–æ–¥–∞–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É action_lower
            return f"STOP LOSS HIT{position_suffix}", "üõë"
        elif 'partial_1 hit' in reason_lower or 'partial_tp1_hit' in action_lower:
            return f"PARTIAL TP 1 HIT{position_suffix}", "üíé"
        elif 'partial_2 hit' in reason_lower or 'partial_tp2_hit' in action_lower:
            return f"PARTIAL TP 2 HIT{position_suffix}", "üíé"
        elif 'partial_3 hit' in reason_lower or 'partial_tp3_hit' in action_lower:
            return f"PARTIAL TP 3 HIT{position_suffix}", "üíé"
        elif 'final tp hit' in reason_lower or ('take profit' in reason_lower and 'partial' not in reason_lower) or 'final_tp_hit' in action_lower:
            return f"FINAL TP HIT{position_suffix}", "üèÜ"
        elif 'volume divergence exit' in reason_lower or 'vol_div_exit' in action_lower:
            return f"VOLUME DIVERGENCE EXIT{position_suffix}", "üìä"
        elif 'breakeven' in reason_lower or 'breakeven_close' in action_lower:
            return f"BREAKEVEN CLOSE{position_suffix}", "‚öñÔ∏è"
        elif 'trailing stop' in reason_lower or 'trailing_sl_hit' in action_lower:
            return f"TRAILING STOP HIT{position_suffix}", "‚ö°"
        elif 'pos_closed_on_tpsl_update_fail' in action_lower: # –ù–æ–≤–∏–π —Ç–∏–ø
            return f"CLOSED (TP/SL Update Fail){position_suffix}", "‚ö†Ô∏è"
        elif 'closed externally' in reason_lower or 'external_close' in action_lower or 'closed_externally' in action_lower:
            return f"EXTERNAL CLOSE{position_suffix}", "üí®"
        elif 'already_closed' in action_lower: # –ó–º—ñ–Ω–µ–Ω–æ –∑ 'already closed' in reason_lower
            return f"ALREADY CLOSED{position_suffix}", "üí®"

        # –ê–Ω–∞–ª—ñ–∑ –∑–∞ action, —è–∫—â–æ reason –Ω–µ –¥–∞–≤ —Ç–æ—á–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
        if 'open' in action_lower:
            return f"OPEN{position_suffix}", "üü¢" if side_upper == "BUY" else "üî¥"

        # –†–æ–∑–±–∏—Ä–∞—î–º–æ action, —è–∫—â–æ –≤—ñ–Ω –º–∞—î —Å–∫–ª–∞–¥–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∑ _close_position)
        # PARTIAL_SL_HIT_BUY, PARTIAL_TP1_HIT_SELL etc.
        if "partial" in action_lower and "close" not in action_lower: # –ù–∞–ø—Ä–∏–∫–ª–∞–¥, PARTIAL_TP1_HIT_BUY
            tp_type_part = "UNKNOWN_TP"
            if "tp1" in action_lower or "partial_1" in action_lower : tp_type_part = "PARTIAL TP 1"
            elif "tp2" in action_lower or "partial_2" in action_lower: tp_type_part = "PARTIAL TP 2"
            elif "tp3" in action_lower or "partial_3" in action_lower: tp_type_part = "PARTIAL TP 3"
            elif "final" in action_lower : tp_type_part = "FINAL TP"

            if "hit" in action_lower:
                return f"{tp_type_part} HIT{position_suffix}", "üíé" if "final" not in tp_type_part.lower() else "üèÜ"

        # –ó–∞–≥–∞–ª—å–Ω—ñ –≤–∏–ø–∞–¥–∫–∏ –∑–∞–∫—Ä–∏—Ç—Ç—è, —è–∫—â–æ action –º—ñ—Å—Ç–∏—Ç—å 'close'
        if 'close' in action_lower or 'closed' in action_lower:
            if 'partial' in action_lower: # –ù–∞–ø—Ä–∏–∫–ª–∞–¥, MANUAL_PARTIAL_CLOSE_BUY
                return f"PARTIAL CLOSE{position_suffix}", "üìä"
            else: # –ù–∞–ø—Ä–∏–∫–ª–∞–¥, MANUAL_CLOSE_BUY
                return f"CLOSE{position_suffix}", "üéØ"

        # –Ø–∫—â–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –ø—ñ–¥—ñ–π—à–ª–æ, –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –±–∞–∑–æ–≤—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é
        default_action_text = action.replace('_', ' ').upper()
        default_emoji = "‚ÑπÔ∏è"
        if side_upper == "BUY": default_emoji = "üìà"
        elif side_upper == "SELL": default_emoji = "üìâ"

        return f"{default_action_text}{position_suffix}", default_emoji
    
    async def send_message(self, message: str, parse_mode: str = 'HTML') -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ Telegram"""
        if not self.bot or not self.chat_id:
            logger.debug("Telegram –±–æ—Ç –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ")
            return False
        
        try:
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=message,
                parse_mode=parse_mode
            )
            return True
            
        except TelegramError as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ Telegram –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {e}")
            return False
        except Exception as e:
            logger.error(f"–ù–µ–æ—á—ñ–∫—É–≤–∞–Ω–∞ –ø–æ–º–∏–ª–∫–∞ Telegram: {e}")
            return False
    
    async def send_bot_status(self, status: str, additional_info: Dict = None) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å—É –±–æ—Ç–∞"""
        if not self.config.get('notification_types', {}).get('status', True):
            return False
        
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            message = f"ü§ñ <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞</b>\n"
            message += f"‚è∞ –ß–∞—Å: {timestamp}\n"
            message += f"üìä –°—Ç–∞—Ç—É—Å: <b>{status}</b>\n"
            
            if additional_info:
                message += "\nüìã <b>–î–æ–¥–∞—Ç–∫–æ–≤–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è:</b>\n"
                for key, value in additional_info.items():
                    message += f"‚Ä¢ {key}: {value}\n"
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Å—Ç–∞—Ç—É—Å—É –±–æ—Ç–∞: {e}")
            return False
    
    async def send_balance_update(self, balance_data: Dict[str, Any]) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É –∑ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–º —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫–æ–º P&L —á–µ—Ä–µ–∑ —Ä—ñ–∑–Ω–∏—Ü—é –±–∞–ª–∞–Ω—Å—ñ–≤"""
        if not self.config.get('notification_types', {}).get('balance', True):
            return False
        
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            message = f"üí∞ <b>–ë–∞–ª–∞–Ω—Å –∞–∫–∞—É–Ω—Ç–∞</b>\n"
            message += f"‚è∞ –ß–∞—Å: {timestamp}\n"
            
            # –ü–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å USDT
            current_usdt_balance = balance_data.get('usdt_balance')
            if isinstance(current_usdt_balance, (int, float)):
                message += f"üíµ USDT: <b>{float(current_usdt_balance):.2f}</b>\n"
            else:
                message += f"üíµ USDT: <b>{current_usdt_balance or '0.00'}</b>\n"

            # ‚úÖ –í–ò–ü–†–ê–í–õ–ï–ù–û: P&L —Ä–æ–∑—Ä–∞—Ö–æ–≤—É—î—Ç—å—Å—è —è–∫ —Ä—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ –ø–æ—Ç–æ—á–Ω–∏–º —Ç–∞ –ø–æ—á–∞—Ç–∫–æ–≤–∏–º –±–∞–ª–∞–Ω—Å–æ–º
            initial_balance = balance_data.get('initial_balance')
            if isinstance(current_usdt_balance, (int, float)) and isinstance(initial_balance, (int, float)):
                pnl_from_balance_diff = float(current_usdt_balance) - float(initial_balance)
                pnl_emoji = "üìà" if pnl_from_balance_diff >= 0 else "üìâ"
                message += f"{pnl_emoji} P&L: <b>{pnl_from_balance_diff:+.4f} USDT</b>\n"
            else:
                # Fallback –Ω–∞ —Å—Ç–∞—Ä–∏–π —Å–ø–æ—Å—ñ–±, —è–∫—â–æ –Ω–µ–º–∞—î –ø–æ—á–∞—Ç–∫–æ–≤–æ–≥–æ –±–∞–ª–∞–Ω—Å—É
                total_pnl_val = balance_data.get('total_pnl', 0)
                if isinstance(total_pnl_val, (int, float)):
                    pnl_val_num = float(total_pnl_val)
                    pnl_emoji = "üìà" if pnl_val_num >= 0 else "üìâ"
                    message += f"{pnl_emoji} P&L: <b>{pnl_val_num:+.4f} USDT</b>\n"
                else:
                    message += f"üìä P&L: <b>{total_pnl_val or 'N/A'}</b>\n"
            
            # –ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ–∑–∏—Ü—ñ–π
            open_positions_count = balance_data.get('open_positions_count', 0)
            message += f"üìç –í—ñ–¥–∫—Ä–∏—Ç–∏—Ö –ø–æ–∑–∏—Ü—ñ–π: <b>{open_positions_count}</b>\n"
            
            # ‚úÖ –í–ò–ü–†–ê–í–õ–ï–ù–û: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–æ—Ä–≥—ñ–≤–ª—ñ
            total_trades = balance_data.get('total_trades', 0)
            winning_trades = balance_data.get('winning_trades', 0)
            losing_trades = balance_data.get('losing_trades', 0)
            
            if total_trades > 0:
                win_rate = (winning_trades / total_trades) * 100
                message += f"\nüìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–æ—Ä–≥—ñ–≤–ª—ñ:</b>\n"
                message += f"üéØ –í—Å—å–æ–≥–æ —É–≥–æ–¥: <b>{total_trades}</b>\n"
                message += f"‚úÖ –í–∏–≥—Ä–∞—à–Ω–∏—Ö: <b>{winning_trades}</b>\n"
                message += f"‚ùå –ü—Ä–æ–≥—Ä–∞—à–Ω–∏—Ö: <b>{losing_trades}</b>\n"
                message += f"üìà –í—ñ–Ω—Ä–µ–π—Ç: <b>{win_rate:.1f}%</b>\n"
                
                # ‚úÖ –í–ò–ü–†–ê–í–õ–ï–ù–û: P&L –≤—ñ–¥ —É–≥–æ–¥ –æ–∫—Ä–µ–º–æ (—Å—É–º–∞ P&L –∑ —Ç–æ—Ä–≥–æ–≤–∏—Ö –∑–∞–ø–∏—Å—ñ–≤)
                total_pnl_from_trades = balance_data.get('total_pnl', 0)
                if isinstance(total_pnl_from_trades, (int, float)):
                    avg_trade = total_pnl_from_trades / total_trades if total_trades > 0 else 0
                    message += f"üí∞ P&L –≤—ñ–¥ —Ç–æ—Ä–≥—ñ–≤–ª—ñ: <b>{total_pnl_from_trades:+.4f} USDT</b>\n"
                    message += f"üìä –°–µ—Ä–µ–¥–Ω—è —É–≥–æ–¥–∞: <b>{avg_trade:+.4f} USDT</b>\n"
                    
                    # –ü–æ–∫–∞–∑—É—î–º–æ —Ä—ñ–∑–Ω–∏—Ü—é –º—ñ–∂ P&L –≤—ñ–¥ –±–∞–ª–∞–Ω—Å—É —Ç–∞ —É–≥–æ–¥ (–∫–æ–º—ñ—Å—ñ—ó, —Å–ª–∏–ø–∞–¥–∂ —Ç–æ—â–æ)
                    if isinstance(current_usdt_balance, (int, float)) and isinstance(initial_balance, (int, float)):
                        balance_pnl = float(current_usdt_balance) - float(initial_balance)
                        difference = balance_pnl - total_pnl_from_trades
                        if abs(difference) > 0.0001:  # –ü–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ —Ä—ñ–∑–Ω–∏—Ü—è –∑–Ω–∞—á–Ω–∞
                            message += f"‚öñÔ∏è –†—ñ–∑–Ω–∏—Ü—è (–∫–æ–º—ñ—Å—ñ—ó/—Å–ª–∏–ø–∞–¥–∂): <b>{difference:+.4f} USDT</b>\n"
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –±–∞–ª–∞–Ω—Å—É: {e}", exc_info=True)
            return False
    
    async def send_trade_notification(self, trade_data: Dict[str, Any]) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ —Ç–æ—Ä–≥—ñ–≤–ª—é –∑ –ø–æ–∫—Ä–∞—â–µ–Ω–∏–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ —Ç–∞ —Ç–æ—á–Ω–∏–º P&L"""
        if not self.config.get('notification_types', {}).get('trades', True):
            return False

        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

            action = trade_data.get('action', 'Unknown Trade Action')
            symbol = trade_data.get('symbol', 'N/A')
            side = trade_data.get('side', 'N/A')
            reason = trade_data.get('reason', '')

            detailed_action_text, action_emoji = self.get_detailed_action_info(action, reason, side)
            message = f"{action_emoji} <b>{detailed_action_text}</b>\n"

            message += f"‚è∞ –ß–∞—Å: {timestamp}\n"
            message += f"üìä –ü–∞—Ä–∞: <b>{symbol}</b>\n"

            price_val = trade_data.get('price') # –¶—ñ–Ω–∞ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∞–±–æ —Ç—Ä–∏–≥–µ—Ä–∞
            if price_val is not None:
                try:
                    price_float = float(price_val)
                    price_str_fmt = str(price_float)
                    decimals = 0
                    if '.' in price_str_fmt:
                        decimals = len(price_str_fmt.split('.')[1])
                        if price_float > 100 and decimals > 2: decimals = 2
                        elif price_float > 1 and decimals > 4: decimals = 4
                        elif decimals > 6: decimals = 6
                    message += f"üí∞ –¶—ñ–Ω–∞: <b>{price_float:.{decimals}f}</b>\n"
                except (ValueError, TypeError):
                    message += f"üí∞ –¶—ñ–Ω–∞: <b>{price_val}</b>\n"
            
            # –î–æ–¥–∞—î–º–æ —Ü—ñ–Ω—É —Ç—Ä–∏–≥–µ—Ä–∞, —è–∫—â–æ –≤–æ–Ω–∞ —î —ñ –≤—ñ–¥—Ä—ñ–∑–Ω—è—î—Ç—å—Å—è –≤—ñ–¥ —Ü—ñ–Ω–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
            trigger_price = trade_data.get('trigger_price_for_close')
            if trigger_price is not None and price_val is not None:
                try:
                    if abs(float(trigger_price) - float(price_val)) > 1e-9: # –Ø–∫—â–æ —Ü—ñ–Ω–∏ —Å—É—Ç—Ç—î–≤–æ –≤—ñ–¥—Ä—ñ–∑–Ω—è—é—Ç—å—Å—è
                        trigger_price_float = float(trigger_price)
                        decimals_trigger = 0
                        if '.' in str(trigger_price_float):
                            decimals_trigger = len(str(trigger_price_float).split('.')[1])
                            if trigger_price_float > 100 and decimals_trigger > 2: decimals_trigger = 2
                            elif trigger_price_float > 1 and decimals_trigger > 4: decimals_trigger = 4
                            elif decimals_trigger > 6: decimals_trigger = 6
                        message += f"üîë –¢—Ä–∏–≥–µ—Ä —Ü—ñ–Ω–∞: <b>{trigger_price_float:.{decimals_trigger}f}</b>\n"
                except (ValueError, TypeError):
                    pass


            quantity_display = trade_data.get('quantity_float', trade_data.get('quantity'))
            if quantity_display is not None:
                try:
                    qty_val = float(quantity_display)
                    qty_str_fmt = str(qty_val)
                    qty_decimals = 0
                    if '.' in qty_str_fmt:
                        qty_decimals = len(qty_str_fmt.split('.')[1])
                        if qty_val < 0.001 and qty_decimals > 8: qty_decimals = 8 # –î–ª—è –¥—É–∂–µ –º–∞–ª–∏—Ö –∫—ñ–ª—å–∫–æ—Å—Ç–µ–π
                        elif qty_val < 1 and qty_decimals > 6 : qty_decimals = 6
                        elif qty_val >=1 and qty_decimals > 4: qty_decimals = 4
                    message += f"üì¶ –ö—ñ–ª—å–∫—ñ—Å—Ç—å: <b>{qty_val:.{qty_decimals}f}</b>\n"
                except (ValueError, TypeError):
                    message += f"üì¶ –ö—ñ–ª—å–∫—ñ—Å—Ç—å: <b>{quantity_display}</b>\n"

            if 'OPEN' in detailed_action_text.upper():
                entry_price_val = trade_data.get('entry_price', trade_data.get('price'))
                if entry_price_val is not None and quantity_display is not None:
                    try:
                        total_value = float(entry_price_val) * float(quantity_display)
                        message += f"üíµ –°—É–º–∞ (–æ—Ä—ñ—î–Ω—Ç–æ–≤–Ω–æ): <b>{total_value:.2f} USDT</b>\n"
                    except (ValueError, TypeError): pass

                sl_val = trade_data.get('stop_loss')
                if sl_val is not None:
                    try:
                        sl_float = float(sl_val)
                        sl_decimals = 2 if sl_float > 100 else 4 if sl_float > 1 else 6
                        message += f"üõë Stop Loss: <b>{sl_float:.{sl_decimals}f}</b>\n"
                    except (ValueError, TypeError):
                        message += f"üõë Stop Loss: <b>{sl_val}</b>\n"

                tp_levels = trade_data.get('take_profits')
                if isinstance(tp_levels, list) and tp_levels:
                    message += f"üéØ Take Profits:\n"
                    for i, tp in enumerate(tp_levels):
                        if isinstance(tp, dict):
                            tp_price = tp.get('price')
                            tp_percentage = tp.get('percentage_to_close')
                            tp_type = tp.get('type', str(i+1))
                            if tp_price is not None and tp_percentage is not None:
                                try:
                                    tp_price_float = float(tp_price)
                                    tp_dec = 2 if tp_price_float > 100 else 4 if tp_price_float > 1 else 6
                                    message += f"  ‚Ä¢ TP {tp_type}: {tp_price_float:.{tp_dec}f} ({float(tp_percentage):.1f}%)\n"
                                except (ValueError, TypeError):
                                    message += f"  ‚Ä¢ TP {tp_type}: {tp_price} ({tp_percentage}%)\n"

                if trade_data.get('confidence') is not None:
                    message += f"üìä –í–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å: <b>{trade_data['confidence']}</b>\n"
                if trade_data.get('volume_surge_active'): message += f"‚ö° Volume Surge –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ!\n"
                if trade_data.get('super_volume_surge_active'): message += f"üåü SUPER Volume Surge –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ!\n"

            if any(keyword in detailed_action_text.upper() for keyword in ['CLOSE', 'HIT', 'EXIT', 'ALREADY', 'FAIL']): # –î–æ–¥–∞–Ω–æ FAIL
                pnl_value_from_data = trade_data.get('pnl')
                pnl_display_text = "<b>N/A</b>"
                pnl_emoji_for_msg = "üìä"

                if pnl_value_from_data is not None:
                    if isinstance(pnl_value_from_data, str) and "N/A" in pnl_value_from_data:
                        pass # –ó–∞–ª–∏—à–∞—î–º–æ N/A
                    else:
                        try:
                            pnl_float = float(pnl_value_from_data)
                            pnl_emoji_for_msg = "üíö" if pnl_float >= 0 else "‚ù§Ô∏è"
                            pnl_display_text = f"<b>{pnl_float:+.4f} USDT</b>"

                            pnl_percentage = trade_data.get('pnl_percentage')
                            if pnl_percentage is not None:
                                try:
                                    pnl_display_text += f" ({float(pnl_percentage):+.2f}%)"
                                except (ValueError, TypeError): pass
                        except (ValueError, TypeError):
                            pnl_display_text = f"<b>{str(pnl_value_from_data)}</b>"

                message += f"{pnl_emoji_for_msg} P&L: {pnl_display_text}\n"

                remaining_qty = trade_data.get('remaining_quantity')
                if remaining_qty is not None and "PARTIAL" in detailed_action_text.upper():
                    try:
                        rem_qty_float = float(remaining_qty)
                        if rem_qty_float > 0.0000001 : # –ü–æ–∫–∞–∑—É—î–º–æ –∑–∞–ª–∏—à–æ–∫, —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –≤—ñ–Ω —î
                            rem_qty_decimals = 0
                            if '.' in str(rem_qty_float): rem_qty_decimals = len(str(rem_qty_float).split('.')[1])
                            if rem_qty_float < 0.001 and rem_qty_decimals > 8: rem_qty_decimals = 8
                            elif rem_qty_float < 1 and rem_qty_decimals > 6 : rem_qty_decimals = 6
                            elif rem_qty_float >=1 and rem_qty_decimals > 4: rem_qty_decimals = 4
                            message += f"üì¶ –ó–∞–ª–∏—à–æ–∫: <b>{rem_qty_float:.{rem_qty_decimals}f}</b>\n"
                    except (ValueError, TypeError):
                        if remaining_qty: message += f"üì¶ –ó–∞–ª–∏—à–æ–∫: <b>{remaining_qty}</b>\n"


            if reason:
                reason_short = reason[:250] + "..." if len(reason) > 250 else reason # –ó–±—ñ–ª—å—à–µ–Ω–æ –ª—ñ–º—ñ—Ç
                message += f"üìù –ü—Ä–∏—á–∏–Ω–∞: {reason_short}\n"
            
            # –î–æ–¥–∞–≤–∞–Ω–Ω—è –¥–µ—Ç–∞–ª—å–Ω–æ—ó –ø—Ä–∏—á–∏–Ω–∏ –∑–∞–∫—Ä–∏—Ç—Ç—è, —è–∫—â–æ —î
            detailed_reason = trade_data.get('detailed_close_reason')
            if detailed_reason and detailed_reason.lower() != reason.lower(): # –Ø–∫—â–æ –≤—ñ–¥—Ä—ñ–∑–Ω—è—î—Ç—å—Å—è –≤—ñ–¥ –æ—Å–Ω–æ–≤–Ω–æ—ó –ø—Ä–∏—á–∏–Ω–∏
                message += f"üî© –î–µ—Ç–∞–ª—ñ –ø—Ä–∏—á–∏–Ω–∏: {detailed_reason}\n"


            exchange_order_id = trade_data.get('exchange_order_id')
            if exchange_order_id:
                message += f"üÜî ID –æ—Ä–¥–µ—Ä–∞: <code>{exchange_order_id}</code>\n"


            details = trade_data.get('details') # –ó–∞–≥–∞–ª—å–Ω—ñ –¥–µ—Ç–∞–ª—ñ
            if details:
                details_short = str(details)[:200] + "..." if len(str(details)) > 200 else str(details)
                message += f"‚ÑπÔ∏è –î–æ–¥–∞—Ç–∫–æ–≤–æ: {details_short}\n"


            return await self.send_message(message)

        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è: {e}", exc_info=True)
            try:
                await self.send_message(f"üö® –ü–æ–º–∏–ª–∫–∞ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è: {str(e)[:200]}")
            except: pass
            return False
  
    async def send_signal_notification(self, signal_data: Dict[str, Any]) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ —Å–∏–≥–Ω–∞–ª"""
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            signal = signal_data.get('signal', 'HOLD')
            symbol = signal_data.get('symbol', 'Unknown')
            confidence_val = signal_data.get('confidence') 
            confidence_str = str(confidence_val) if confidence_val is not None else "N/A"

            if signal == 'HOLD': 
                return False 
            
            # –ü–æ–∫—Ä–∞—â–µ–Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Å–∏–≥–Ω–∞–ª—ñ–≤
            if signal == 'BUY':
                signal_emoji = "üü¢"
                signal_text = "BUY (LONG)"
            elif signal == 'SELL':
                signal_emoji = "üî¥"
                signal_text = "SELL (SHORT)"
            else:
                signal_emoji = "‚ö™"
                signal_text = signal
            
            message = f"{signal_emoji} <b>–¢–æ—Ä–≥–æ–≤–∏–π —Å–∏–≥–Ω–∞–ª: {signal_text}</b>\n"
            message += f"‚è∞ –ß–∞—Å: {timestamp}\n"
            message += f"üìä –ü–∞—Ä–∞: <b>{symbol}</b>\n"
            message += f"üí™ –í–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å: <b>{confidence_str}</b>\n" 
            
            entry_price_val = signal_data.get('entry_price')
            if entry_price_val is not None:
                 message += f"üí∞ –¶—ñ–Ω–∞ –≤—Ö–æ–¥—É: <b>{float(entry_price_val):.6f}</b>\n"
            
            stop_loss_val = signal_data.get('stop_loss_price') 
            if stop_loss_val is not None:
                message += f"üõë Stop Loss: <b>{float(stop_loss_val):.6f}</b>\n"
            
            tp_levels = signal_data.get('take_profits')
            if isinstance(tp_levels, list) and tp_levels:
                message += f"üéØ Take Profits:\n"
                for i, tp in enumerate(tp_levels[:3], 1):
                    if isinstance(tp, dict):
                        tp_price = tp.get('price')
                        tp_percentage = tp.get('percentage_to_close') 
                        tp_type = tp.get('type', str(i))
                        if tp_price is not None and tp_percentage is not None:
                            message += f"  ‚Ä¢ TP {tp_type}: {float(tp_price):.6f} ({float(tp_percentage):.1f}%)\n"
            
            if signal_data.get('volume_surge_active'):
                message += f"‚ö° <b>Volume Surge!</b>\n"
            if signal_data.get('super_volume_surge_active'):
                 message += f"üåü <b>SUPER Volume Surge!</b>\n"
            
            market_regime_info = signal_data.get('market_regime_status', "N/A") 
            message += f"üìà –†–µ–∂–∏–º: <b>{market_regime_info}</b>\n"
            
            reason = signal_data.get('reason')
            if reason:
                message += f"üìù –ü—Ä–∏—á–∏–Ω–∞: {reason}\n"
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ —Å–∏–≥–Ω–∞–ª: {e}", exc_info=True)
            return False
    
    async def send_error_notification(self, error_data: Dict[str, Any]) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –ø–æ–º–∏–ª–∫—É"""
        if not self.config.get('notification_types', {}).get('errors', True):
            return False
        
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            error_type = error_data.get('type', 'Unknown')
            error_message_val = error_data.get('message', 'Unknown error')
            # –û–±–º–µ–∂–µ–Ω–Ω—è –¥–æ–≤–∂–∏–Ω–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–æ–º–∏–ª–∫—É
            error_message_str = str(error_message_val)
            if len(error_message_str) > 1000: # –û–±–º–µ–∂–µ–Ω–Ω—è, —â–æ–± –Ω–µ –ø–µ—Ä–µ–≤–∏—â–∏—Ç–∏ –ª—ñ–º—ñ—Ç–∏ Telegram
                error_message_str = error_message_str[:1000] + "..."

            message = f"üö® <b>–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞</b>\n"
            message += f"‚è∞ –ß–∞—Å: {timestamp}\n"
            message += f"‚ùå –¢–∏–ø: <b>{error_type}</b>\n"
            message += f"üìù –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {error_message_str}\n" # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –æ–±–º–µ–∂–µ–Ω–∏–π —Ä—è–¥–æ–∫
            
            if 'symbol' in error_data:
                message += f"üìä –ü–∞—Ä–∞: <b>{error_data['symbol']}</b>\n"
            
            if 'action' in error_data:
                message += f"üîß –î—ñ—è: <b>{error_data['action']}</b>\n"
            
            # –î–æ–¥–∞–º–æ API –≤—ñ–¥–ø–æ–≤—ñ–¥—å, —è–∫—â–æ –≤–æ–Ω–∞ —î —ñ —Ü–µ –ø–æ–º–∏–ª–∫–∞ –±—ñ—Ä–∂—ñ
            if 'api_response' in error_data and "EXCHANGE" in error_type.upper():
                api_response_str = str(error_data['api_response'])
                if len(api_response_str) > 500:
                    api_response_str = api_response_str[:500] + "..."
                message += f"üìÑ –í—ñ–¥–ø–æ–≤—ñ–¥—å API: {api_response_str}\n"

            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –ø–æ–º–∏–ª–∫–∏: {e}") # –ù–µ exc_info, —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ —Ä–µ–∫—É—Ä—Å—ñ—ó –ª–æ–≥—É–≤–∞–Ω–Ω—è
            return False
    
    async def send_market_analysis(self, analysis_data: Dict[str, Any]) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ –∞–Ω–∞–ª—ñ–∑—É —Ä–∏–Ω–∫—É"""
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            message = f"üìä <b>–ê–Ω–∞–ª—ñ–∑ —Ä–∏–Ω–∫—É</b>\n"
            message += f"‚è∞ –ß–∞—Å: {timestamp}\n\n"
            
            for symbol, data in analysis_data.items():
                if isinstance(data, dict):
                    signal = data.get('signal', 'HOLD')
                    confidence = data.get('confidence', 0)
                    
                    if signal == 'BUY':
                        signal_emoji = "üü¢"
                        signal_text = "LONG"
                    elif signal == 'SELL':
                        signal_emoji = "üî¥"
                        signal_text = "SHORT"
                    else:
                        signal_emoji = "‚ö™"
                        signal_text = "HOLD"
                    
                    message += f"{signal_emoji} <b>{symbol}</b>: {signal_text} ({confidence}/4)\n"
                    
                    if data.get('volume_surge'):
                        message += f"  ‚ö° Volume Surge\n"
                    if data.get('super_volume_surge'):
                        message += f"  üåü SUPER Volume Surge\n"
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –∞–Ω–∞–ª—ñ–∑—É —Ä–∏–Ω–∫—É: {e}", exc_info=True)
            return False
    
    async def send_daily_summary(self, summary_data: Dict[str, Any]) -> bool:
        """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ –¥–µ–Ω–Ω–æ–≥–æ –ø—ñ–¥—Å—É–º–∫—É"""
        try:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            message = f"üìà <b>–î–µ–Ω–Ω–∏–π –ø—ñ–¥—Å—É–º–æ–∫</b>\n"
            message += f"‚è∞ –î–∞—Ç–∞: {timestamp[:10]}\n\n"
            
            total_trades = summary_data.get('total_trades', 0)
            winning_trades = summary_data.get('winning_trades', 0)
            losing_trades = summary_data.get('losing_trades', 0)
            
            message += f"üéØ –í—Å—å–æ–≥–æ —É–≥–æ–¥: <b>{total_trades}</b>\n"
            
            if total_trades > 0:
                win_rate = (winning_trades / total_trades) * 100
                message += f"‚úÖ –ü—Ä–∏–±—É—Ç–∫–æ–≤–∏—Ö: <b>{winning_trades}</b>\n"
                message += f"‚ùå –ó–±–∏—Ç–∫–æ–≤–∏—Ö: <b>{losing_trades}</b>\n"
                message += f"üìä –í—ñ–Ω—Ä–µ–π—Ç: <b>{win_rate:.1f}%</b>\n\n"
            
            total_pnl = summary_data.get('total_pnl', 0)
            pnl_emoji = "üíö" if total_pnl >= 0 else "‚ù§Ô∏è"
            message += f"{pnl_emoji} –ó–∞–≥–∞–ª—å–Ω–∏–π P&L: <b>{total_pnl:+.4f} USDT</b>\n"
            
            current_balance = summary_data.get('current_balance', 0)
            message += f"üí∞ –ü–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å: <b>{current_balance:.2f} USDT</b>\n"
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –¥–µ–Ω–Ω–æ–≥–æ –ø—ñ–¥—Å—É–º–∫—É: {e}", exc_info=True)
            return False
    
    async def test_connection(self) -> bool:
        """–¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è –∑'—î–¥–Ω–∞–Ω–Ω—è –∑ Telegram"""
        if not self.bot:
            return False
        
        try:
            test_message = "ü§ñ –¢–µ—Å—Ç –∑'—î–¥–Ω–∞–Ω–Ω—è: Telegram –±–æ—Ç –ø—Ä–∞—Ü—é—î!"
            return await self.send_message(test_message)
            
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è Telegram –∑'—î–¥–Ω–∞–Ω–Ω—è: {e}")
            return False